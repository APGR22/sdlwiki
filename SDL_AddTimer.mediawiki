<!-- pragma section-numbers off -->
<!-- pragma disable-camelcase -->
'''DRAFT'''

= SDL_AddTimer =
Use this function to add a new timer to the pool of timers already running.


== Syntax ==
```c++
SDL_TimerID SDL_AddTimer(Uint32               interval,
                         SDL_NewTimerCallback callback,
                         void*                param)
```

== Function Parameters ==
{|
|'''interval'''
|^the time, in milliseconds, for the new timer to wait/cycle^; see [[#Remarks|Remarks]] for details
|-
|'''callback'''
|^the callback function to run/call^ ''-or-'' *the SDL timer callback function which is called when the specified '''interval''' elapses*; see [[#callback|Remarks]] for details
|-
|'''param'''
|^the parameters of the timer^ ''-or-'' *the user parameter which is passed to the callback function*
|}

<<Color2(green,Should the callback function SDL_NewTimerCallback details be listed here instead of in Remarks?)>>

== Return Value ==
Returns a timer ID or NULL when an error occurs^; call [[SDL_GetError]]() for more information.^

== Code Examples ==
*
```c++
/* Start the timer; the callback below will be executed after the delay */

delay = (33 / 10) * 10;  /* To round it down to the nearest 10 ms */
my_timer_id = SDL_AddTimer(delay, my_callbackfunc, my_callback_param);

...

Uint32 my_callbackfunc(Uint32 interval, void *param)
{
    SDL_Event event;
    SDL_UserEvent userevent;

    /* In this example, our callback pushes an SDL_USEREVENT event
    into the queue, and causes ourself to be called again at the
    same interval: */

    userevent.type = SDL_USEREVENT;
    userevent.code = 0;
    userevent.data1 = NULL;
    userevent.data2 = NULL;

    event.type = SDL_USEREVENT;
    event.user = userevent;

    SDL_PushEvent(&event);
    return(interval);
}
```
Note that it is possible to avoid the multithreading problems with SDL timers by giving to userevent.data1 the address of a function you want to be executed and to userevent.data2 its params, and then deal with it in the event loop. 
```c++
/* with the same code as before: */
Uint32 my_callbackfunc(Uint32 interval, void *param)
{
    /* ... */
    userevent.data1 = &my_function;
    userevent.data2 = param;

    /* ... */
    return(interval);
}

/* Now the event loop */
SDL_Event event;
while (SDL_PollEvent (&event))
{
    switch(event.type)
    {
        case SDL_USEREVENT: {
            /* and now we can call the function we wanted to call in the timer but couldn't because of the multithreading problems */
            void (*p) (void*) = event.user.data1;
            p(event.user.data2);
            break;
        }
        /* ... */
    }
}
```
*

== Remarks ==
*<br/>The granularity of the timer ^used by '''interval'''^ is platform-dependent, but you should count on it being at least 10 ms as this is the most common number. This means that if you request a 16 ms timer, your callback will run approximately 20 ms later on an unloaded system. If you wanted to set a flag signaling a frame update at 30 frames per second (every 33 ms), you might set a timer for 30 ms (see [[#Code Example|Code Example]]). 

<span id="callback"></span>
''^[[SDL_AddTimer]]()^ adds a callback function to be run after the specified number of milliseconds has elapsed.'' 
The callback function is passed the current timer interval ''and the user supplied parameter from the [[SDL_AddTimer]]() call'' and returns the next timer interval. If the returned value ''from the callback'' is the same as the one passed in, the ''timer'' continues ''at the same rate''. If the ''returned value from the callback is'' 0, the ''timer'' is canceled.

<<Color2(green,The next paragraph is from the current header and seems to be redundant with the above except for the parts in italics.  It also seems to be identical to the one for SDL_SetTimer.  Which is the better version?)>>

The callback function is passed the current timer interval and returns the next timer interval.  If the returned value is the same as the one passed in, the ''periodic alarm'' continues, ''otherwise a new alarm is scheduled''.  If the ''callback returns'' 0, the ''periodic alarm'' is canceled.

The '''callback''' parameters are as follows:
 ```
Uint32 SDL_NewTimerCallback(Uint32 interval, 
                            void*  param)
```

Another way to cancel a currently-running timer is by calling [[SDL_RemoveTimer]]() with the timer's ID (which was returned from [[SDL_AddTimer]]()).

The timer callback function may run in a different thread than your main program, and so shouldn't call any functions from within itself. However, you may always call [[SDL_PushEvent]]().

If you use this function, you need to pass SDL_INIT_TIMER to SDL_Init. <br/>*


== Related Functions ==
:[[SDL_PushEvent]] *
:[[SDL_RemoveTimer]] *

----
[[CategoryAPI]], [[CategoryTimer]]
