<!-- pragma section-numbers off -->
<!-- pragma disable-camelcase -->
'''DRAFT'''

= SDL_FillRect =
Use this function to perform a fast fill of the given rectangle with color.


== Syntax ==
```c++
int SDL_FillRect(SDL_Surface*    dst,
                 const SDL_Rect* rect,
                 Uint32          color)
```

== Function Parameters ==
{|
|'''dst'''
|a pointer to the destination surface / [[SDL_Surface]] containing the rectangle
|-
|'''rect'''
|a pointer to the rectangle / [[SDL_Rect]] to fill
|-
|'''color'''
|the color to fill the rectangle with
|}

== Return Value ==
Returns 0 on success, or -1 on failure; call [[SDL_GetError]]() for more information.

== Code Examples ==
```c++
You can add your code example here
```

== Remarks ==
If '''rect''' is NULL, the whole surface will be filled with color.

,,The,, '''color''' should be a pixel of the format used by the surface, and can be generated by the [[SDL_MapRGB]]() *or [[SDL_MapRGBA]]()*function^s^.  *If the color value contains an alpha value then the destination is simply "filled" with that alpha information, no blending takes place.

If there is a clip rectangle set on the destination (set via [[SDL_SetClipRect]]()), then this function will clip based on the intersection of the clip rectangle and the ''',,dst,,rect''' rectangle, and the ''',,dst,,rect''' rectangle will be modified to represent the area actually filled.

<<Color2(green,I suspect that this section is now defunct.  The referenced function has no page in 1.3.)>>

If you call this on the video surface (ie: the value of SDL_GetVideoSurface()) you may have to update the video surface to see the result. This can happen if you are using a shadowed surface that is not double buffered in Windows XP using build 1.2.9. <br/>*

== Related Functions ==
:[[SDL_BlitSurface]] *
:[[SDL_FillRects]]
:[[SDL_MapRGB]] *
:[[SDL_MapRGBA]] *
:[[SDL_SetClipRect]] ?*

----
[[CategoryAPI]], [[CategorySurface]]
