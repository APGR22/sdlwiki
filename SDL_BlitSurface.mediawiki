<!-- pragma section-numbers off -->
<!-- pragma disable-camelcase -->
'''DRAFT'''

= SDL_BlitSurface =
Use this function to perform a fast blit from the source surface to the destination surface.


== Syntax ==
```c++
int SDL_BlitSurface(SDL_Surface* src,
                    SDL_Rect*    srcrect,
                    SDL_Surface* dst,
                    SDL_Rect*    dstrect)
```

== Function Parameters ==
{|
|'''src'''
|a pointer to the source [[SDL_Surface]] containing '''srcrect'''
|-
|'''srcrect'''
|a pointer to the [[SDL_Rect]] containing the source pixels
|-
|'''dst'''
|a pointer to the destination [[SDL_Surface]] containing '''dstrect'''
|-
|'''dstrect'''
|a pointer to the destination [[SDL_Rect]] to be filled
|}

== Return Value ==
Returns 0 if the blit is successful or a negative error code on failure; call [[SDL_GetError]]() for more information.

See [[#video|Remarks]] for details if the return value is -2.

== Code Examples ==
```c++
You can add your code example here
```

== Remarks ==
<<Color2(green,Should colour be changed to color?)>>

This is the public blit function, and it performs rectangle validation and clipping before passing it to [[SDL_LowerBlit]](). <<Color2(green,Does this remark apply only to Upper<code></code>Blit and not to Blit<code></code>Surface?)>>

You should call [[SDL_BlitSurface]]() unless you know exactly how SDL blitting works internally and how to use the other blit functions.

<<Color2(green,The above 2 remarks were re-ordered and have been moved to the top of the section because they seem more appropriately placed there. They were at the bottom in the reverse order.)>>

The blit function should not be called on a locked surface. <<Color2(green,This was listed below the following but seemed more appropriately placed here.)>> *<br/>(i.e. when you use your own drawing functions you may need to lock a surface, but this is not the case with [[SDL_BlitSurface]]().)<br/>
Like most surface manipulation functions in SDL, it should not be used together with OpenGL.<br/>*

This assumes that the source and destination rectangles are the same size. If either '''srcrect''' or '''dstrect''' are NULL, the entire surface ('''src''' or '''dst''') is copied. The final blit rectangles are saved in '''srcrect''' and '''dstrect''' after all clipping is performed.

*<br/><<Color2(green,Is this redundant to above? Should some of it be kept because it says more? Is this wording preferable?)>> The width and height in '''srcrect''' determine the size of the copied rectangle. Only the position is used in the '''dstrect''' (the width and height are ignored). Blits with negative '''dstrect''' coordinates will be clipped properly.

If '''srcrect''' is NULL, the entire surface is copied. If '''dstrect''' is NULL, then the destination position (upper left corner) is (0, 0).

The final blit rectangle is saved in '''dstrect''' after all clipping is performed ('''srcrect''' is not modified). <br/>*

<<Color2(green,Should the following go in a code box or is this formatting acceptable? Should \verbatim and \endverbatim be removed?)>>

The blit semantics for surfaces with and without alpha and colorkey are defined as follows:
 \verbatim
 RGBA->RGB:
  SDL_SRCALPHA set:
   alpha-blend (using alpha-channel).
   SDL_SRCCOLORKEY ignored.
  SDL_SRCALPHA not set:
   copy RGB.
   if SDL_SRCCOLORKEY set, only copy the pixels matching the RGB values of the source colour key, ignoring alpha in the comparison.

 RGB->RGBA:
  SDL_SRCALPHA set:
   alpha-blend (using the source per-surface alpha value);
   set destination alpha to opaque.
  SDL_SRCALPHA not set:
   copy RGB, set destination alpha to source per-surface alpha value.
  both:
   if SDL_SRCCOLORKEY set, only copy the pixels matching the source colour key.

 RGBA->RGBA:
  SDL_SRCALPHA set:
   alpha-blend (using the source alpha channel) the RGB values;
   leave destination alpha untouched. [Note: is this correct?]
   SDL_SRCCOLORKEY ignored.
  SDL_SRCALPHA not set:
   copy all of RGBA to the destination.
   if SDL_SRCCOLORKEY set, only copy the pixels matching the RGB values of the source colour key, ignoring alpha in the comparison.

 RGB->RGB:
  SDL_SRCALPHA set:
   alpha-blend (using the source per-surface alpha value).
  SDL_SRCALPHA not set:
   copy RGB.
  both:
   if SDL_SRCCOLORKEY set, only copy the pixels matching the source colour key.
 \endverbatim

<span id="video"></span> If either of the surfaces were in video memory, and the blit returns -2, the video memory was lost, so it should be reloaded with artwork and re-blitted:
 ```
@code
while ( SDL_BlitSurface(image, imgrect, screen, dstrect) == -2 ) {
while ( SDL_LockSurface(image) < 0 )
Sleep(10);
-- Write image pixels to image->pixels --
SDL_UnlockSurface(image);
}
@endcode
```
<<Color2(green,Should @code and @endcode be removed here?)>>

This happens under DirectX 5.0 when the system switches away from your fullscreen application. The lock will also fail until you have access to the video memory again.

*<br/>The results of blitting operations vary greatly depending on whether SDL_SRCALPHA is set or not. See SDL_SetAlpha (<<Color2(green,This does not have a page. Does it still exist?)>>) for an explanation of how this affects your results. Colorkeying and alpha attributes also interact with surface blitting, as the following pseudo-code should hopefully explain. 
```
if (source surface has SDL_SRCALPHA set) {
    if (source surface has alpha channel (that is, format->Amask != 0))
        blit using per-pixel alpha, ignoring any colour key
    else {
        if (source surface has SDL_SRCCOLORKEY set)
            blit using the colour key AND the per-surface alpha value
        else
            blit using the per-surface alpha value
    }
} else {
    if (source surface has SDL_SRCCOLORKEY set)
        blit using the colour key
    else
        ordinary opaque rectangular blit
}
```

Note: the SDL blitter does not (yet) have the capability of scaling the blitted surfaces up or down like it is the case with other more sophisticated blitting mechanisms. You have to figure something out for yourself if you want to scale images (e.g. use SDL_gfx).

Note: when you're blitting between two alpha surfaces, normally the alpha of the destination acts as a mask. If you want to just do a "dumb copy" that doesn't blend, you have to turn off the SDL_SRCALPHA flag on the source surface. This is how it's supposed to work, but can be surprising when you're trying to combine one image with another and both have transparent backgrounds. <br/>*

== Related Functions ==
:[[SDL_LowerBlit]]
:[[SDL_UpperBlit]]

----
[[CategoryAPI]], [[CategorySurface]]
