<!-- pragma section-numbers off -->
<!-- pragma disable-camelcase -->
'''DRAFT'''

= SDL_ConvertAudio =
Use this function to convert audio data to a desired audio format.


== Syntax ==
```c++
int SDL_ConvertAudio(SDL_AudioCVT* cvt)
```

== Function Parameters ==
{|
|'''cvt'''
|an [[SDL_AudioCVT]] structure that was previously set up; see [[#cvt|Remarks]] for details
|}

== Return Value ==

Returns 0 if the conversion was completed successfully, ,,otherwise,, ^or^ -1 ,,is returned and,, ^on error;^ call [[SDL_GetError]]() for more information.

== Code Examples ==
```c++
/* Converting some WAV data to hardware format */
void my_audio_callback(void *userdata, Uint8 *stream, int len);

SDL_AudioSpec *desired, *obtained;
SDL_AudioSpec wav_spec;
SDL_AudioCVT  wav_cvt;
Uint32 wav_len;
Uint8 *wav_buf;
int ret;

/* Allocated audio specs */
desired = malloc(sizeof(SDL_AudioSpec));
obtained = malloc(sizeof(SDL_AudioSpec));

/* Set desired format */
desired->freq=22050;
desired->format=AUDIO_S16LSB;
desired->samples=8192;
desired->callback=my_audio_callback;
desired->userdata=NULL;

/* Open the audio device */
if ( SDL_OpenAudio(desired, obtained) < 0 ){
  fprintf(stderr, "Couldn't open audio: %s\n", SDL_GetError());
  exit(-1);
}
        
free(desired);

/* Load the test.wav */
if( SDL_LoadWAV("test.wav", &wav_spec, &wav_buf, &wav_len) == NULL ){
  fprintf(stderr, "Could not open test.wav: %s\n", SDL_GetError());
  SDL_CloseAudio();
  free(obtained);
  exit(-1);
}
                                            
/* Build AudioCVT */
ret = SDL_BuildAudioCVT(&wav_cvt,
                        wav_spec.format, wav_spec.channels, wav_spec.freq,
                        obtained->format, obtained->channels, obtained->freq);

/* Check that the convert was built */
if(ret==-1){
  fprintf(stderr, "Couldn't build converter!\n");
  SDL_CloseAudio();
  free(obtained);
  SDL_FreeWAV(wav_buf);
}

/* Setup for conversion, copy original data to new buffer*/
wav_cvt.buf = malloc(wav_len * wav_cvt.len_mult);
wav_cvt.len = wav_len;
memcpy(wav_cvt.buf, wav_buf, wav_len);

/* We can delete to original WAV data now */
SDL_FreeWAV(wav_buf);

/* And now we're ready to convert */
SDL_ConvertAudio(&wav_cvt);

/* do whatever */
.
.
.
.
```

== Remarks ==
<<Color2(green,Does [[SDL_BuildAudioCVT]]() initialize the structure create the buffer and fill it with audio data or does it require other actions to create the buffer and fill it with data?  If the function does all of the above then the second paragraph below should probably replace the first.  If not then the first paragraph below should be kept and possibly modified to include information about how to create the buffer and fill it.)>>

<span id="cvt"></span> Once you have initialized the '''cvt''' structure using [[SDL_BuildAudioCVT]](), created an audio buffer <code>cvt->buf</code>, and filled it with <code>cvt->len</code> bytes of audio data in the source format, ^the structure can be passed to^ this function ^which^ will convert it in-place to the desired format.

''-or-''

<span id="cvt"></span> Once you have initialized the '''cvt''' structure, created an audio buffer <code>cvt->buf</code>, and filled it with <code>cvt->len</code> bytes of audio data in the source format using [[SDL_BuildAudioCVT]](), ^the structure can be passed to^ this function ^which^ will convert it in-place to the desired format.



<<Color2(green,How do you allocate the buffer?  Should that info be included here or is that common knowledge?)>>

The data conversion may expand the size of the audio data, so the buffer <code>cvt->buf</code> should be allocated after the '''cvt''' structure is initialized by [[SDL_BuildAudioCVT]](), and should be <code>cvt->len*cvt->len_mult</code> bytes long.



If the conversion completed successfully then the converted audio data can be read from <code>cvt->buf</code>. The amount of valid, converted, audio data in the buffer is equal to <code>cvt->len*cvt->len_ratio</code>. 


== Related Functions ==
:[[SDL_BuildAudioCVT]]

----
[[CategoryAPI]], [[CategoryAudio]]
