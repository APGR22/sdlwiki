<!-- pragma section-numbers off -->
<!-- pragma disable-camelcase -->
'''DRAFT'''

= SDL_GL_GetProcAddress =
Use this function to get the address of an OpenGL function.


== Syntax ==
```c++
void* SDL_GL_GetProcAddress(const char* proc)
```

== Function Parameters ==
{|
|'''proc'''
|a pointer to an OpenGL function
|}

== Return Value ==
*<br/>Returns the address of the GL function proc, or NULL  if the function is not found.<br/>*

<<Color2(green,Is there a RV for void*?  The OpenGL function is passed to the callback function.???)>>

== Code Examples ==
*<br/>
```c++
typedef void (APIENTRY * GL_ActiveTextureARB_Func)(unsigned int);
GL_ActiveTextureARB_Func glActiveTextureARB_ptr = 0;
int has_multitexture=1;
.
.
.
/* Get function pointer */
glActiveTextureARB_ptr=(GL_ActiveTextureARB_Func) SDL_GL_GetProcAddress("glActiveTextureARB");

/* Check for a valid function ptr */
if(!glActiveTextureARB_ptr){
  fprintf(stderr, "Multitexture Extensions not present.\n");
  has_multitexture=0;
}
.
.
.
.
if(has_multitexture){
  glActiveTextureARB_ptr(GL_TEXTURE0_ARB);
  .
  .
}
else{
  .
  .
}
```
<br/>*

== Remarks ==
*<br/>If the GL library is loaded at runtime with [[SDL_GL_LoadLibrary]](), then all GL functions must be retrieved this way. Usually this is used to retrieve function pointers to OpenGL extensions. Note that this function needs an OpenGL context to ,,function,, ^work^ properly, so it should be called after [[SDL_SetVideoMode]]() has been called (with the SDL_OPENGL flag).

<<Color2(green,Can't find SDL_SetVideoMode. Has it been replaced?)>>

OpenGL function pointers must be declared APIENTRY as in the example code. This will ensure the proper calling convention is followed on platforms where this matters (Win32) thereby avoiding stack corruption. In a Win32 build environment, APIENTRY should be defined as <code>__stdcall</code>. <br/>*

== Related Functions ==
:[[SDL_GL_LoadLibrary]]
:[[SDL_GL_UnloadLibrary]]

----
[[CategoryAPI]], [[CategoryVideo]]
